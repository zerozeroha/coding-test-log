/**
 * 문제 설명
 * 배열 arr가 주어졌을 때, 연속으로 중복된 숫자는 하나만 남기고 제거한 배열을 반환하는 문제입니다.
 * 즉, [1, 1, 3, 3, 0, 1, 1] → [1, 3, 0, 1] 처럼 "연속된 동일 숫자"는 하나만 유지합니다.
 * 순서를 유지하는 것이 핵심이며, 전체 중복 제거와는 다릅니다.
 *
 * 제한사항
 * - 1 ≤ arr.length ≤ 1,000,000
 * - 0 ≤ arr[i] ≤ 9
 *
 * 입출력 예
 * solution([1, 1, 3, 3, 0, 1, 1]) → [1, 3, 0, 1]
 * solution([4, 4, 4, 3, 3]) → [4, 3]
 */

function solution(arr) {
  const result = [];

  for (let i = 0; i < arr.length; i++) {
    // 첫 요소이거나, 이전 요소와 다를 때만 추가
    if (i === 0 || arr[i] !== arr[i - 1]) {
      result.push(arr[i]);
    }
  }

  return result;
}

/**
 *  헷갈렸던 부분 정리
 *
 * 1. 왜 Set을 쓰면 안 될까?
 *    → Set은 **전체 중복 제거**를 하기 때문에,
 *      예: [1,1,3,1] → Set은 [1,3]이 되며 순서도 보장되지 않아 문제의 의도와 다름.
 *      이 문제는 **"연속된 중복"만 제거**하는 것임.

 * 2. i === 0 조건은 왜 필요할까?
 *    → 첫 번째 요소는 비교 대상(arr[i-1])이 없기 때문에 무조건 결과 배열에 포함시켜야 함.

 * 3. return 위치 주의
 *    → for문 내부에서 return하면 반복이 중간에 끊기니 반드시 반복문 밖에서 `return result;`

 */
